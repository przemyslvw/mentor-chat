import { Component, ViewChild, ElementRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatDialogModule, MatDialogRef } from '@angular/material/dialog';
import { MatProgressBarModule } from '@angular/material/progress-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatChipsModule } from '@angular/material/chips';
import { MatCardModule } from '@angular/material/card';
import { MatListModule } from '@angular/material/list';
import { MatTooltipModule } from '@angular/material/tooltip';
import { FormsModule } from '@angular/forms';
import { Functions, httpsCallable } from '@angular/fire/functions';

import { FileUploadService } from '../../../../../shared/services/file-upload.service';
import { QuotesService } from '../../../services/quotes.service';
import { FileSizePipe } from '../../../../../shared/pipes/file-size.pipe';

interface QuoteData {
  content: string;
  author: string;
  category: string;
  tags: string[];
  isActive: boolean;
  id?: string;
  mentorId?: string;
  createdAt?: Date;
  updatedAt?: Date;
}

interface FileUploadResult<T = QuoteData> {
  success: boolean;
  message: string;
  data?: T[];
  errors?: {
    line: number;
    error: string;
    data: T;
  }[];
}

interface EmbeddingResponse {
  embedding: number[];
}

interface SimilarityResponse {
  results: Array<{
    text: string;
    score: number;
    metadata: any;
  }>;
}

@Component({
  selector: 'app-quote-upload',
  standalone: true,
  imports: [
    CommonModule,
    MatButtonModule,
    MatIconModule,
    MatDialogModule,
    MatProgressBarModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatFormFieldModule,
    MatInputModule,
    MatExpansionModule,
    MatChipsModule,
    MatCardModule,
    MatListModule,
    MatTooltipModule,
    FormsModule,
    FileSizePipe,
  ],
  templateUrl: './quote-upload.component.html',
  styleUrls: ['./quote-upload.component.scss'],
})
export class QuoteUploadComponent {
  @ViewChild('fileInput') fileInput!: ElementRef;
  
  selectedFile: File | null = null;
  isUploading = false;
  isTesting = false;
  uploadProgress = 0;
  uploadResult: FileUploadResult | null = null;
  
  // Embedding preview
  embeddingPreview: {
    text: string;
    embedding: number[];
    loading: boolean;
    error?: string;
  } | null = null;
  
  // Similarity test
  testQuery = '';
  similarityResults: Array<{
    text: string;
    score: number;
    metadata: any;
  }> = [];

  constructor(
    private snackBar: MatSnackBar,
    private dialogRef: MatDialogRef<QuoteUploadComponent>,
    private fileUploadService: FileUploadService,
    private quotesService: QuotesService,
    private functions: Functions
  ) {}

  onFileSelected(event: any): void {
    this.selectedFile = event.target.files[0];
  }

  async onUpload(): Promise<void> {
    if (!this.selectedFile) return;

    this.isUploading = true;
    this.uploadProgress = 0;
    this.uploadResult = null;

    try {
      const result = await this.fileUploadService.uploadFile<QuoteData>(
        this.selectedFile,
        'quotes',
        (progress) => {
          this.uploadProgress = progress;
        }
      );

      this.uploadResult = result;
      this.snackBar.open('Upload completed successfully', 'Close', {
        duration: 3000,
      });
    } catch (error) {
      console.error('Upload failed:', error);
      this.snackBar.open('Upload failed. Please try again.', 'Close', {
        duration: 5000,
        panelClass: ['error-snackbar'],
      });
    } finally {
      this.isUploading = false;
    }
  }

  async generateEmbeddingPreview(text: string) {
    if (!text.trim()) return;
    
    this.embeddingPreview = {
      text,
      embedding: [],
      loading: true
    };
    
    try {
      const generateEmbedding = httpsCallable<{ text: string }, EmbeddingResponse>(
        this.functions,
        'generateEmbedding'
      );
      const result = await generateEmbedding({ text });
      
      if (result.data) {
        this.embeddingPreview = {
          ...this.embeddingPreview,
          embedding: result.data.embedding,
          loading: false
        };
      }
    } catch (error) {
      console.error('Error generating embedding:', error);
      this.embeddingPreview = {
        ...this.embeddingPreview!,
        error: 'Failed to generate embedding',
        loading: false
      };
    }
  }
  
  async testSimilarity() {
    if (!this.testQuery.trim()) return;
    
    this.isTesting = true;
    this.similarityResults = [];
    
    try {
      const findSimilar = httpsCallable<{ query: string; limit: number }, SimilarityResponse>(
        this.functions,
        'findSimilarQuotes'
      );
      const result = await findSimilar({
        query: this.testQuery,
        limit: 5
      });
      
      if (result.data) {
        this.similarityResults = result.data.results || [];
      }
    } catch (error) {
      console.error('Error testing similarity:', error);
      this.snackBar.open('Failed to test similarity', 'Close', {
        duration: 3000,
        panelClass: ['error-snackbar']
      });
    } finally {
      this.isTesting = false;
    }
  }

  downloadErrors(): void {
    if (!this.uploadResult?.errors?.length) return;

    const errorData = this.uploadResult.errors;
    const blob = new Blob([JSON.stringify(errorData, null, 2)], { type: 'application/json' });
    const url = window.URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'quote_upload_errors.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
  }

  onCancel(): void {
    this.dialogRef.close();
  }

  get hasErrors(): boolean {
    return !!(this.uploadResult?.errors?.length);
  }

  get hasWarnings(): boolean {
    return (this.uploadResult?.data?.length || 0) < (this.uploadResult?.errors?.length || 0);
  }
}
